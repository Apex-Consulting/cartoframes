const GLOBAL_FILTER = 'global';
const LOCAL_FILTER = 'viewport';
const LOCAL_MODE = 'fast';

function cleanStyleName(name) {
  return name.replace('Style', '');
}

function decodeJSONData(data, encodeData) {
  try {
    if (encodeData) {
      const decodedJSON = pako.inflate(atob(data), { to: 'string' });
      return JSON.parse(decodedJSON);
    } else {
      return JSON.parse(data);
    }
  } catch(error) {
    throw new Error(`
    Error: "${error}". CARTOframes is not able to parse your local data because it is too large.
    Please, disable the data compresion with encode_data=False in your Layer class.
  `);
  }
}

async function initialize() {
  const basemap = '{{ basemap }}';
  const bounds = {{ bounds }};
  const camera = {{ camera|tojson }};
  const layersDef = {{ layers|tojson }};

  let credentials = null;
  let dataview = null;
  let layer = null;
  let source = null;
  let style = null;
  let styleName = null;
  let widgetMode = null;

  const deckMap = carto.viz.createMap({
    basemap: basemap,
    viewState: camera
  });

  let layerI = layersDef.length - 1;  // Their "IDs" are reversed
  for (const layerDef of layersDef) {
    if (layerDef.type === 'Query') {
      credentials = new carto.auth.Credentials(layerDef.credentials.username, layerDef.credentials.api_key, layerDef.credentials.base_url);
      source = new carto.viz.source.SQL(layerDef.data, {credentials});

    } else {
      source = new carto.viz.source.GeoJSON(decodeJSONData(layerDef.data, layerDef.encode_data));
    }

    if (!!layerDef.viz && !!layerDef.viz.value) {
      style = carto.viz.style[cleanStyleName(layerDef.viz.name)](layerDef.viz.value, layerDef.viz.options);

    } else if (!!layerDef.viz) {
      style = carto.viz.style[cleanStyleName(layerDef.viz.name)](layerDef.viz.options);
    }

    layer = new carto.viz.Layer(source, style);

    if (!!layerDef.interactivity.hover) {
      for (const hover of layerDef.interactivity.hover) {
        if (typeof hover.format === 'string') {
            hover.format = d3.format(hover.format);
        }
      }

      await layer.setPopupHover(layerDef.interactivity.hover);
    }

    if (!!layerDef.interactivity.click) {
      for (const hover of layerDef.interactivity.hover) {
        if (typeof hover.format === 'string') {
            hover.format = d3.format(hover.format);
        }
      }

      await layer.setPopupClick(layerDef.interactivity.click);
    }

    await layer.addTo(deckMap);

    let widgetI = 0;
    for (const widgetDef of layerDef.widgets) {
      widgetMode = widgetDef.is_global ? {
        spatialFilter: 'global'
      } : {
        spatialFilter: 'viewport',
        mode: 'fast'
      };

      if (typeof widgetDef.options.format === 'string') {
        widgetDef.options.format = d3.format(widgetDef.options.format);
      }

      if (widgetDef.type === 'category') {
        dataview = new carto.viz.dataview.Category(layer, widgetDef.value, {
          operation: 'count',
          ...widgetMode
        });

        new carto.viz.widget.Category(`as-category-widget#layer${layerI}_widget${widgetI}`, dataview, {
          showClearButton: true,
          disableInteractivity: widgetDef.options.readOnly,
          format: widgetDef.options.format
        });

      } else if (widgetDef.type === 'formula') {
        dataview = new carto.viz.dataview.Formula(layer, widgetDef.value, {
          operation: widgetDef.operation,
          ...widgetMode
        });

        new carto.viz.widget.Formula(`as-formula-widget#layer${layerI}_widget${widgetI}`, dataview, {
          format: widgetDef.options.format
        });

      } else if (widgetDef.type === 'histogram') {
        dataview = new carto.viz.dataview.Histogram(layer, widgetDef.value, {
          bins: widgetDef.options.buckets,
          ...widgetMode
        });

        new carto.viz.widget.Histogram(`as-histogram-widget#layer${layerI}_widget${widgetI}`, dataview, {
          showClear: true,
          disableInteractivity: widgetDef.options.readOnly,
          format: widgetDef.options.format
        });
      }

      widgetI++;
    }

    new carto.viz.Legend('as-legend-color-category-point', layer, {label: 'manolo'});

    layerI--;
  }

  const viewport = deckMap.getViewports()[0];
  const {longitude, latitude, zoom} = viewport.fitBounds(bounds);
  const viewState = Object.assign({}, {longitude, latitude, zoom}, camera);

  deckMap.setProps({
    viewState: viewState
  });
}

initialize();
