const GLOBAL_FILTER = 'global';
const LOCAL_FILTER = 'viewport';
const LOCAL_MODE = 'fast';

// Decoding encoding GeoJSON
function decodeJSONData(data, encodeData) {
  try {
    if (encodeData) {
      const decodedJSON = pako.inflate(atob(data), {to: 'string'});
      return JSON.parse(decodedJSON);

    } else {
      return JSON.parse(data);
    }

  } catch(error) {
    throw new Error(`
      Error: "${error}". CARTOframes is not able to parse your local data because it is too large.
      Please, disable the data compresion with encode_data=False in your Layer class.
    `);
  }
}

// Adding a `style` HTML element to the `head` one
function addCSS(css) {
  let head = document.head || document.getElementsByTagName('head')[0];
  let styleNode = document.createElement('style');
  head.appendChild(styleNode);

  styleNode.type = 'text/css';
  if (styleNode.styleSheet){
    styleNode.styleSheet.cssText = css;

  } else {
    styleNode.appendChild(document.createTextNode(css));
  }
}

async function initialize() {
  const basemap = '{{ basemap }}';
  const bounds = {{ bounds }};
  const camera = {{ camera|tojson }};
  const layersDef = {{ layers|tojson }};
  const layerSelector = '{{ layer_selector }}' === 'False' ? false : true;

  let credentials = null;
  let dataview = null;
  let layer = null;
  let layers = {};
  let source = null;
  let style = null;
  let widgetMode = null;

  let layerI = 0;
  let legendI = 0;
  let widgetI = 0;

  const deckMap = carto.viz.createMap({
    basemap: basemap,
    viewState: camera
  });

  layerI = layersDef.length - 1;  // Their "IDs" are reversed
  for (const layerDef of layersDef) {

    // Source
    // CAROT source
    if (layerDef.type === 'Query') {
      credentials = new carto.auth.Credentials(layerDef.credentials.username, layerDef.credentials.api_key, layerDef.credentials.base_url);
      source = new carto.viz.source.SQL(layerDef.data, {credentials});

    // GeoJSON source for DataFrames
    } else {
      source = new carto.viz.source.GeoJSON(decodeJSONData(layerDef.data, layerDef.encode_data));
    }

    // Style
    // Style from variable
    if (!!layerDef.viz && !!layerDef.viz.value) {
      style = carto.viz.style[layerDef.viz.name](layerDef.viz.value, layerDef.viz.options);

    // Style from no variable
    } else if (!!layerDef.viz) {
      style = carto.viz.style[layerDef.viz.name](layerDef.viz.options);

    // No style
    } else {
      style = null;
    }

    // Layer
    layer = style ? new carto.viz.Layer(source, style) : new carto.viz.Layer(source);

    // Interactivity
    // Hover interactivity
    if (!!layerDef.interactivity.hover) {
      for (const hover of layerDef.interactivity.hover) {
        if (typeof hover.format === 'string') {
            hover.format = d3.format(hover.format);
        }
      }

      await layer.setPopupHover(layerDef.interactivity.hover, {autoWidth: true, closeButton: false});
    }

    // Click interactivity
    if (!!layerDef.interactivity.click) {
      for (const click of layerDef.interactivity.click) {
        if (typeof click.format === 'string') {
            click.format = d3.format(click.format);
        }
      }

      await layer.setPopupClick(layerDef.interactivity.click,  {autoWidth: true, closeButton: true});
    }

    await layer.addTo(deckMap);

    // Widgets
    widgetI = 0;
    for (const widgetDef of layerDef.widgets) {

      // Widget mode
      widgetMode = widgetDef.is_global ? {
        spatialFilter: 'global'
      } : {
        spatialFilter: 'viewport',
        mode: 'fast'
      };

      // Widget format
      if (typeof widgetDef.options.format === 'string') {
        widgetDef.options.format = d3.format(widgetDef.options.format);
      }

      // Category widget
      if (widgetDef.type === 'category') {
        dataview = new carto.viz.dataview.Category(layer, widgetDef.value, {
          operation: 'count',
          ...widgetMode
        });

        new carto.viz.widget.Category(`as-category-widget#layer${layerI}_widget${widgetI}`, dataview, {
          showClearButton: true,
          disableInteractivity: widgetDef.options.readOnly,
          format: widgetDef.options.format
        });

      // Formula widget
      } else if (widgetDef.type === 'formula') {
        dataview = new carto.viz.dataview.Formula(layer, widgetDef.value, {
          operation: widgetDef.operation,
          ...widgetMode
        });

        new carto.viz.widget.Formula(`as-formula-widget#layer${layerI}_widget${widgetI}`, dataview, {
          format: widgetDef.options.format
        });

      // Histogram widget
      } else if (widgetDef.type === 'histogram') {
        dataview = new carto.viz.dataview.Histogram(layer, widgetDef.value, {
          bins: widgetDef.options.buckets,
          ...widgetMode
        });

        new carto.viz.widget.Histogram(`as-histogram-widget#layer${layerI}_widget${widgetI}`, dataview, {
          showClearButton: true,
          disableInteractivity: widgetDef.options.readOnly,
          format: widgetDef.options.format
        });
      }

      widgetI++;
    }

    // Legends
    legendI = 0;
    for (const legendDef of layerDef.legends) {
      if (typeof legendDef.format === 'string') {
        legendDef.format = d3.format(legendDef.format);
      }

      let legendId = `layer${layerI}_map${layerDef.map_index}_legend${legendI}`;
      new carto.viz.Legend(`as-legend-${legendDef.type}#${legendId}`, layer, legendDef);

      // Legend with layer selector
      if (layerSelector) {
        let selectorId = `${legendId}_selector`;
        let selectorElement = document.getElementById(selectorId);
        layers[selectorId] = layer;

        selectorElement.addEventListener('change', (event) => {
          let targetElement = event.target || event.srcElement;
          let targetLayer = layers[selectorId];

          if (targetLayer.isVisible()){
            targetLayer.hide();

          } else {
            targetLayer.show();
          }
        });
      }

      legendI++;
    }

    layerI--;
  }

  // Adding CSS for layer selectors
  if (layerSelector) {
    addCSS('div.as-legend--wrapper {display: inline; padding-left: 0px;};');
    addCSS('div.as-legend--wrapper as-widget-header {display: inline-block;};');
  }

  // Setting the right zoom and center, and optional pitch and bearing
  const viewport = deckMap.getViewports()[0];
  const {longitude, latitude, zoom} = viewport.fitBounds(bounds);
  const viewState = Object.assign({}, {longitude, latitude, zoom}, camera);

  deckMap.setProps({
    viewState: viewState
  });
}

initialize();
